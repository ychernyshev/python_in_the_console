variables_and_data_types = {
        'variable': '\nVariable - це "комірка" пам\'яті, у котру вкладається необхідний тип даних: літера, символ,'
                    ' число, список, кортеж, словник, set, логічний тип даних, бинарний тип даних (байт), None '
                    '(тобто, нічого).\nУ базовому стані, коли дані просто оголошені, вони називаються "літералами". Є строкові, числові, логічні літерали та літерали-колекції. Вони всі вже були перелічені вище.',
        'data_types': '\nТе, над чим необхідно провести операцію. Тобто, символьна строка, число (може бути ціле, дробне), колекція (набір, або, перелік даних), логічний тип даних (True або False)',
        'data_types__str': '\nБудь який набір елементів, будь то літери, цифри, спеціальні символи, що огортаються подвійними або одинарними лапками.\nНаприклад: "приклад, 3332, !?&@".\nІніціалізується як variable_name = "text".\nВикликається за назвою змінної, тобто - variable_name\nНаприклад: new_variable = variable_name (При команді print(new_variable) отримаємо строку - "text")',
        'data_types__int': '\nЗвичайні цілі числа, накшталт 1, 2, 3, 4, і так далі',
        'data_types__float': '\nЧисла з плаваючою крапкою, або дрібні числа, накштал, 1.001, 5.7, 10.94, і так далі',
        'data_types__complex': '\nЯкщо коротко, то комплексні числа, це ті числа, квадрат котрих дорівнює -1, або ж це квадратний корінь з від\'ємних чисел. Тобто, якесь число і (від лат. imaginarius - уявний) помножене на самого себе дорівнює -1 (і * і = -1). \nКомплексні числа використовуються у механіці, аеро- та гідродинаміці, в алгебраїчній і неевклідових геометріях, теорії чисел.\nУ Python, під час запису у змінну, викликається наступна функція із параметрами: complex(real, imaginary). Перший параметр -  число, що представляє дійсну частину комплексного числа, яке може бути у вигляді строки типу "3+5j" (тоді, другий параметр опускається). Другий параметр опційний. За замовченням дорівнює 0.',
        'data_types__list': '\nНауково - це впорядкована послідовність елементів. По простому, це перелік чогось - цифр, строк, логічних операторів, інших списків, кортежей, словників, set та інше. Записується, як variable_name = [1, "two", False, [1, "two", False], {1: "і так далі"}]',
        'data_types__tuple': '\nКортежі представляють собою, умовно, список (науково - незмінний об\'кт), який не можна змінити, хоча, не на практиці, якщо у кортежі є список, який змінити можливо, у данному особливому випадку, кортеж становиться змінним об\'єктом, хоча, насправді, це змінюється не кортеж, а список у середині нього. Тобто, незмінний об\'єкт кортеж, може містити змінні елементи, наприклад: списки. Але, навіщо тоді кортежі? Для гарантування незмінності елементів. Звичайна зміна у кортежі неможлива, як у роботі зі списками. Інтерпретатор заборонить: TypeError: "tuple" object does not support item assignment',
        'data_types__dict': '\nСловник дозволяє дозволяє зберігати перелік елементів, так само, як і список, але, на відміну від списку, у словнока є ключі, за контрими, у майбутньому будуть зберегатись значення. Наприклад: variable_name = {"Name": "Pavlo", "Surname": "Vadym"}. Це дозволяє зберігати значення більш логічною конструкцією, та й "витягати" або перебирати словники простіше, ніж було б, якби ми щось схоже робили на базі списків. Відповідно, у словників немає індексів, як у списків. У словників замість індексів виступають ключі. "Name" або "Surname", як у прикладі вище.',
        'data_types__set': '\nSet (Множина) дозволяє не створювати дублі інформації. Тобто, наприклад, якщо ви захочемо зберегти set variable_name = {6, 6, 6}, збереженим виявиться set variable_name = {6}, так само, і із строками variable_name = {"c1", "c1", "c1",}. Результатом буде set - variable_name = {"c1"}.\nЗауважте, що пустий set - це словник. Тобто, ось так: variable_name = {}. Якщо вам потрібен сет, обов\'язково у set потрібно що небудь записати. Також, set приймає тільки незмінні об\'єкти: числа, строки, кортежі. Інакше, інтерпритатор покаже помилку: TypeError: unhashable type: "list"',
        'data_types__frozenset': '\nЗаморожений Set має властивість кортежа. Тобто, додати у нього нічого не можна, видалити, теж, як і змінити. Цей сет є таким, яким його створили. Навіщо потрібно? Властивість set нікуди не ділась, відповідно, всі повторювані елементи будуть відкинуті',
        'data_types__bool': '\nЦе логічний тип даних. Потрібний, щоб задати умову True, тобто, "Так", чи - False, тобто, "Ні".',
        'data_types__bytes': '\nПо науці, це незмінні послідовності окремих байтів. На ділі, записується, як строкова змінна із додаванням префіксу "b". Наприклад: b"\xd0\x91\xd0\xb0\xd0\xb9\xd1\x82\xd0\xb8".decode("utf-8") отримаємо слово "Байти". Так само напишемо "Байти".encode("utf-8") й отримаємо b"\xd0\x91\xd0\xb0\xd0\xb9\xd1\x82\xd0\xb8". Навіщо вони потрібні? До прикладу, прочитати з файлу, або записати у файл, для роботи із буфером обміну пам\'яті.',
        'data_types__bytearray': '\nНа відміну від звичайного bytes, bytearray можна змінити. Наприклад, пробігтись по ньому циклом на перезаписати. b = bytearray(b"hello world!") for i in range(len(b)): b[i] += i. Отримаємо: bytearray(b"Hfnos|&~w{vo-")',
        'data_types__memoryview': '\nПовертає посилання на буфер обміну пам\'яті, у котрій, у якості аргументу, переданий об\єкт, що підтримує протокол буферу обміну, тобто, це bytes та bytearray',
        'data_types__NoneType': '\nЦе є "нічого". Навіщо потрібне? Наприклад, для перевірки наявності чогось. Допустимо, потрібно перевірити, чи є зображення у базі даних, якщо немає, тобто, None, вивести зображення-заглушку',
    }


def command_list(user_command):
    for key, value in variables_and_data_types.items():
        if user_command == key:
            print(value)
        # else:
        #     cprint(f'Невідома команда "{user_command}". Команда "help" покаже список діючих команд', 'yellow')
        #     break

