variables_and_data_types = {
        'variable': '\nVariable - це "комірка" пам\'яті, у котру вкладається необхідний тип даних: літера, символ,'
                    ' число, список, кортеж, словник, set, логічний тип даних, бинарний тип даних (байт), None '
                    '(тобто, нічого).\nУ базовому стані, коли дані просто оголошені, вони називаються "літералами". Є строкові, числові, логічні літерали та літерали-колекції. Вони всі вже були перелічені вище.',
        'data_types': '\nТе, над чим необхідно провести операцію. Тобто, символьна строка, число (може бути ціле, дробне), колекція (набір, або, перелік даних), логічний тип даних (True або False)',
        'data_types__str': '\nБудь який набір елементів, будь то літери, цифри, спеціальні символи, що огортаються подвійними або одинарними лапками.\nНаприклад: "приклад, 3332, !?&@".\nІніціалізується як variable_name = "text".\nВикликається за назвою змінної, тобто - variable_name\nНаприклад: new_variable = variable_name (При команді print(new_variable) отримаємо строку - "text")',
        'data_types__int': '\nЗвичайні цілі числа, накшталт 1, 2, 3, 4, і так далі',
        'data_types__float': '\nЧисла з плаваючою крапкою, або дрібні числа, накштал, 1.001, 5.7, 10.94, і так далі',
        'data_types__complex': '\nЯкщо коротко, то комплексні числа, це ті числа, квадрат котрих дорівнює -1, або ж це квадратний корінь з від\'ємних чисел. Тобто, якесь число і (від лат. imaginarius - уявний) помножене на самого себе дорівнює -1 (і * і = -1). \nКомплексні числа використовуються у механіці, аеро- та гідродинаміці, в алгебраїчній і неевклідових геометріях, теорії чисел.\nУ Python, під час запису у змінну, викликається наступна функція із параметрами: complex(real, imaginary). Перший параметр -  число, що представляє дійсну частину комплексного числа, яке може бути у вигляді строки типу "3+5j" (тоді, другий параметр опускається). Другий параметр опційний. За замовченням дорівнює 0.',
        'data_types__list': '\nНауково - це впорядкована послідовність елементів. По простому, це перелік чогось - цифр, строк, логічних операторів, інших списків, кортежей, словників, set та інше. Записується, як variable_name = [1, "two", False, [1, "two", False], {1: "і так далі"}]',
        'data_types__tuple': '\nКортежі представляють собою, умовно, список (науково - незмінний об\'кт), який не можна змінити, хоча, не на практиці, якщо у кортежі є список, який змінити можливо, у данному особливому випадку, кортеж становиться змінним об\'єктом, хоча, насправді, це змінюється не кортеж, а список у середині нього. Тобто, незмінний об\'єкт кортеж, може містити змінні елементи, наприклад: списки. Але, навіщо тоді кортежі? Для гарантування незмінності елементів. Звичайна зміна у кортежі неможлива, як у роботі зі списками. Інтерпретатор заборонить: TypeError: "tuple" object does not support item assignment',
        'data_types__dict': '\nСловник дозволяє дозволяє зберігати перелік елементів, так само, як і список, але, на відміну від списку, у словнока є ключі, за контрими, у майбутньому будуть зберегатись значення. Наприклад: variable_name = {"Name": "Pavlo", "Surname": "Vadym"}. Це дозволяє зберігати значення більш логічною конструкцією, та й "витягати" або перебирати словники простіше, ніж було б, якби ми щось схоже робили на базі списків. Відповідно, у словників немає індексів, як у списків. У словників замість індексів виступають ключі. "Name" або "Surname", як у прикладі вище.',
        'data_types__set': '\nSet (Множина) дозволяє не створювати дублі інформації. Тобто, наприклад, якщо ви захочемо зберегти set variable_name = {6, 6, 6}, збереженим виявиться set variable_name = {6}, так само, і із строками variable_name = {"c1", "c1", "c1",}. Результатом буде set - variable_name = {"c1"}.\nЗауважте, що пустий set - це словник. Тобто, ось так: variable_name = {}. Якщо вам потрібен сет, обов\'язково у set потрібно що небудь записати. Також, set приймає тільки незмінні об\'єкти: числа, строки, кортежі. Інакше, інтерпритатор покаже помилку: TypeError: unhashable type: "list"',
        'data_types__frozenset': '\nЗаморожений Set має властивість кортежа. Тобто, додати у нього нічого не можна, видалити, теж, як і змінити. Цей сет є таким, яким його створили. Навіщо потрібно? Властивість set нікуди не ділась, відповідно, всі повторювані елементи будуть відкинуті',
        'data_types__bool': '\nЦе логічний тип даних. Потрібний, щоб задати умову True, тобто, "Так", чи - False, тобто, "Ні".',
        'data_types__bytes': '\nПо науці, це незмінні послідовності окремих байтів. На ділі, записується, як строкова змінна із додаванням префіксу "b". Наприклад: b"\\xd0\\x91\\xd0\\xb0\\xd0\\xb9\\xd1\\x82\\xd0\\xb8".decode("utf-8") отримаємо слово "Байти". Так само напишемо "Байти".encode("utf-8") й отримаємо b"\\xd0\\x91\\xd0\\xb0\\xd0\\xb9\\xd1\\x82\\xd0\\xb8". Навіщо вони потрібні? До прикладу, прочитати з файлу, або записати у файл, для роботи із буфером обміну пам\'яті.',
        'data_types__bytearray': '\nНа відміну від звичайного bytes, bytearray можна змінити. Наприклад, пробігтись по ньому циклом на перезаписати. b = bytearray(b"hello world!") for i in range(len(b)): b[i] += i. Отримаємо: bytearray(b"Hfnos|&~w{vo-")',
        'data_types__memoryview': '\nПовертає посилання на буфер обміну пам\'яті, у котрій, у якості аргументу, переданий об\єкт, що підтримує протокол буферу обміну, тобто, це bytes та bytearray',
        'data_types__NoneType': '\nЦе є "нічого". Навіщо потрібне? Наприклад, для перевірки наявності чогось. Допустимо, потрібно перевірити, чи є зображення у базі даних, якщо немає, тобто, None, вивести зображення-заглушку',
    }


string_and_string_methods = {
    'str__capitalize': '\nПереводить першу літеру строки у верхній регистр. Тобто, робить великою',
    'str__casefold': '\nАналог lower(), але, на відміну від останнього, більш якісно використовує Unicode для переведення строки у нижній регистр. Наприклад, німецьку літеру ß, тобто "ss", lower() не зможе перевести у нижній регістр, навідміну від casefold().',
    'str__center': '\nЦей метод дозволяє цетрувати вказану строку методом додавання рівної кількості отступів по боках строки. Синтаксис наступний: string.center(5). У данному прикладі буде додано по 5 пробілів з обох боків строки.',
    'str__count': '\nПовертає перший індекс зазначеної літери. Якщо літера повторюється, їх індекси вже не повертає. Синтаксис: string.count("char")',
    'str__encode': '\nПредставляє строку, як байт код. Починається строка з літери "b", далі, лапки, тобто b"" й у них саме представлення. Кожний символ вмісту строки звіряється з таблицею ANCII, та, якщо, символу у таблиці немає, наприклад, викаристана українська "ї" (у таблиці ANCII присутні лише літери англійського алфавіту), символ матиме байтовий вигляд, що починаєтся з "\\x". Наприклад, щодо "ї", це буде: b"\\xd1\\x97"',
    'str__endswith': '\nПовертає True, якщо строка завершуюється зазначеним символом. Синтаксис: string.endswith("."). Зауважте! Регистр має значення.',
    'str__expandtabs': '\nЦей метод додає вказану кількість пробілів меж символами строки. Синтаксис: s = "s\tt\tr" s2 = s.expandtabs(5) print(s2)',
    'str__find': '\nМетод дозволяє знаходити порядковий індекс знаку у стрічці. Синтаксис: string.find("char"). Зауважте! Метод приймає у якості аргументу строку. Тобто, значення у лапках. Цей метод виконує таку ж саму функцію, що й метод index()',
    'str__format': '\nЦей метод - попередник f-стрічок, що з\'явилися у Python версії 3.6. Синтаксис методу наступний: "name: {0}, price: {1}$".format("string", 45). Тобто, спочатку пишеться строка, у котрій, у фігурних дужках вказується позиційний номер, починаючи з нуля, а у параметрах методу зазначаються дані, що підставляються у оголошені у стрічці позиційні номери. Зауважте! Кількість параметрів методу обмежано трьома. У f-трічці подібні обмежання не прийнято.',
    'str__format_map': '\nЦей метод пропонує обрати словник, з якого за ключами, вказаними у стрічці, можливо витягнути значення цих ключів. Синтаксис: str = "My name is {name} and I am a {job_title}" my_dict = {"name": "Eugene", "job_title": "Python Developer"} print(str.format_map(my_dict). Аналогічний результат буде й у виклику: print(str.format(**my_dict)).',
    'str__index': '\nМетод дозволяє знаходити порядковий індекс знаку у стрічці. Синтаксис: string.index("char"). Зауважте! Метод приймає у якості аргументу строку. Тобто, значення у лапках. Цей метод виконує таку ж саму функцію, що й метод find()',
    'str__isalnum': '\nМетод повертає False, якщо у стручці присутні додткові символи, такі, як "!", "?", ",", "." та інші. У інакшому випадку - True.',
    'str__isalpha': '\n',
    'str__isascii': '\nПовартає True, якщо у рядку присутні лише символи з таблиці ASCII. Таблиця ASCII містить латиські літери, цифри, розділові знаки, математичні символи, дужки та інше (Із вмістом таблиці можливо ознайомитися за наступним посиланням: https://www.asciitable.com/). Відповідно, якщо у рядку є символи, що не входять у таблицю ASCII, до прикладу, літери українського алфавіту, метод поверне False.',
    'str__isdecimal': '\nМетод поверне True, якщо рядок складається лише з літер будь-якої мови. Наявність, додатково, будь-яких знаків, ще, змусить метод повернути False.',
    'str__isdigit': '\nМетод поверне True, якщо рядок складається лише з цифр. Наявність, додатково, будь-яких знаків чи літер, ще, змусить метод повернути False.',
    'str__isidentifier': '\nМетод повертає True, якщо строка починається із літери будь-якого регистру. Початок рядка із цифри чи спеціального символу змусить метод повернути False.',
    'str__islower': '\nМетод повертає True, якщо у рядку всі літери у малому регистрі. Якщо ні, це змусить метод повернути False.',
    'str__isnumeric': '\nМетод повертає True, якщо рядок складається виключно із цифр. Якщо ні, це змусить метод повернути False.',
    'str__isprintable': '\nІснують символи, котрі можливо відправити на друк (тобто, вивести на єекран), а є, котрі - неможливо. Недрукованими символами є символи Unicode із категорії Other або Separator, за винятком символу пробілу з ASCII (0x20), який вважається друкованим. Тому, метод поверне True, якщо у рядку усі символи можливо розрукувати, або, поверне False, якщо у рядку знайдеться недрукований символ, наприклад, позначка переносу на новий рядок "\\n", позначка табуляції "\\t" та інше.',
    'str__isspace': '\nМетод повертає True, якщо рядодк складається із символу пробілу. Інакше - False.',
    'str__istitle': '\nМетод повертає True, якщо рядок починається з літери у великому регистрі. Інакще, пвертає - False.',
    'str__isupper': '\nМетод повертає True, якщо рядок складається з літер лишу у великому регистрі. Інакще, пвертає - False.',
    'str__join': '\nМетод дозволяє перетворити елементи кортежу чи списку у один рядок із додаванням зазделегіть зазначеного розділового знаку між елементами. Синтаксис: myTuple = ("John", "Peter", "Vicky") str = "!".join(myTuple) print(str). Вивід буде наступним: "John!Peter!Vicky".',
    'str__ljust': '\nМетод додає зазначену кількість пробілів зліва додаткового рядку від попереднього. Синтаксис: txt = "banana" str = txt.ljust(10) print(str, "is my favorite fruit."). Вивід буде наступним: "banana     is my favorite fruit".',
    'str__lower': '\nПереводить/Конвертує всі літери строки у нижній регістр. Тобто, робить всі літери маленькими',
    'str__lstrip': '\nВидаляє усі пробіли з лівого буку строки',
    'str__maketrans': '\nМетод дозволяє у зазначеному рядку робити заміну вказаного символу на інший. Синтаксис: txt = "Hello Sam 3!" mytable = str.maketrans("3", "4") print(txt). Вивід буде наступним: "Hello Sam!". Даний метод є аналогом методу replace().',
    'str__partition': '\nМетод дозволяє перетворити рядок у кортеж, що завжди складається з трьох елементів. Зазначена діляка рядка стає одним елементом кортежу, а діляки рядк перед та після зазначеного, стають іншими елементами картежу. Зауважте! Якщо вкладати у елемент не буде що, метод вкладе пустий рядок. Синтаксис: txt = "I could eat bananas all day" x = txt.partition("I could") print(x). Вивід буде наступним: "("", "I could", " eat bananas all day")". Даний метод є аналогом методу rpartition()',
    'str__replace': '\nМетод дозволяє у зазначеному рядку робити заміну вказаного символу на інший. Синтаксис: txt = "Hello Sam 3!" x = txt.replace("Sam", "Pam") print(x). Вивід буде наступним: "Hello Sam!". Даний метод є аналогом методу maketrans()',
    'str__rfind': '\nМетод дозволяє визначити з якого індексу починається зазначене слово чи символ у рядку. Синтаксис: txt = "Mi casa, su casa 7." x = txt.rfind("7") print(x). Вивід буде наступним: 17.  Даний метод є аналогом методу rindex().',
    'str__rindex': '\nМетод дозволяє визначити з якого індексу починається зазначене слово чи символ у рядку. Синтаксис: txt = "Mi casa, su casa 7." x = txt.rfind("7") print(x). Вивід буде наступним: 17. Даний метод є аналогом методу rfind().',
    'str__rjust': '\nМетод зсуває рядок на зазначену кількість пробілів від лівого краю екрану. Синтаксис: txt = "banana" x = txt.rjust(20)',
    'str__rpartition': '\nМетод дозволяє перетворити рядок у кортеж, що завжди складається з трьох елементів. Зазначена діляка рядка стає одним елементом кортежу, а діляки рядк перед та після зазначеного, стають іншими елементами картежу. Зауважте! Якщо вкладати у елемент не буде що, метод вкладе пустий рядок. Синтаксис: txt = "I could eat bananas all day" x = txt.partition("I could") print(x). Вивід буде наступним: "("", "I could", " eat bananas all day")". Даний метод є аналогом методу partition()',
    'str__rsplit': '\nМетод перетворює рядок у список за вказаним розділовим знаком, що є у рядку. Наприклад, за комою. Можливо зазначини не існуючий розділовий знак, але, тоді, увесь рядок буде переміщений у один елемент списку, а за наявним роділовим знаком, у різні. Розділовий знак можна не зазначати. Синтаксис: txt = "apple! banana! cherry" x = txt.rsplit("!") print(x). Вивід буде наступним: ["apple", " banana", " cherry"]. аний метод є аналогом методу split()',
    'str__rstrip': '\nВидаляє усі пробіли з правого боку рядку',
    'str__split': '\nМетод перетворює рядок у список за вказаним розділовим знаком, що є у рядку. Наприклад, за комою. Можливо зазначини не існуючий розділовий знак, але, тоді, увесь рядок буде переміщений у один елемент списку, а за наявним роділовим знаком, у різні. Розділовий знак можна не зазначати. Синтаксис: txt = "apple! banana! cherry" x = txt.rsplit("!") print(x). Вивід буде наступним: ["apple", " banana", " cherry"]. Даний метод є аналогом методу rsplit()',
    'str__splitlines': '\nМетод дозволяє рядок, що має перенос рядків за допомогою \\n перетворювати у список, у якому кажний з цих рядків стає елементом списку. Якщо переносу рядку немає, увесь рядок становиться одним елементом списку.',
    'str__startswith': '\nМетод дозволяє визначити чи рядок починається із зазначеного слова чи символу. Синтаксис: txt = "!Hello, welcome to my world." x = txt.startswith("!")',
    'str__strip': '\nВидаляє усі пробіли з правого та лівого боків рядку',
    'str__swapcase': '\nМетод переводить усі літери рядку, що знаходяться у верхньому ригистрі у нижній ригистр, та, навпаки, усі літери, що знаходяться у нижньому ригистрі - у верхній. Наприклад: "hELLO mY nAME iS peter".',
    'str__title': '\nПереводить усі перші літери усіх слів рядка у верхній регістр. Тобто, робить великими.',
    'str__translate': '\nМетод дозволяє, користуючись таблицею ASCII, зазначивши код символу із цієї таблиці, зробити її заміну у рядку. Синтаксис: mydict = {83:  80} txt = "Hello Sam!" print(txt.translate(mydict)). Вивід буде наступним: "Hello Pam!"',
    'str__upper': '\nПереводить/Конвертує усі літери рядка у нижній регістр. Тобто, робить усі літери великими',
    'str__zfill': '\nМетод дозволяє додавати нулі перез числом. Зауважте! Метод рахує індекс для вставки нуля починаючи зправа. Тобто, якщо число складається з двох цифр, наприклад, 50, якщо вказати 3, як параметр методу, метод додасть тільки один нуль, тому що, перші дві цифри, це число 50. Синтаксис: txt = "5" x = txt.zfill(3)',
}


collections_and_data_collections = {
    '': '',
}


logical_instructions_and_loops = {
    '': '',
}


generators_and_itarators = {
    '': '',
}


functions = {
    '': '',
}


errors_and_exclusion = {
    '': '',
}


classes = {
    '': '',
}
